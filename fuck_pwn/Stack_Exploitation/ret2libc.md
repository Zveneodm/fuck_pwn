# ret2libc
泄露libc基地址之后，使用ROP方法执行system("/bin/sh")
### 泄露libc的方法
1.栈溢出调用puts/printf一类输出函数（通过plt来调用），传参64位需要寻找gadgets，32位直接按正确顺序放到栈上，参数为GOT表项。

2.一般总会有一个偏移于__libc_start_main的地址在栈上，可以通过一些零字节处理的失误或者格式化字符串漏洞来打印出来。

3.利用unsorted bin的双向链表性质，泄露main_arena的地址，而main_arena是libc中的一个全局变量，所以可以获得libc基址
### 构造ROP链

#### 64位

函数参数分别放在rdi,rsi,rdx,rcx,r8,r9上，其余的参数通过栈来传递。

系统调用号由rax来传递。

<img width="310" height="327" alt="image" src="https://github.com/user-attachments/assets/c5c32c93-acb8-460e-8f76-724bc0579cdb" />

#### 32位
参数直接放在栈上：

<img width="314" height="350" alt="image" src="https://github.com/user-attachments/assets/29b128fc-bc42-4408-9d38-1591f7b15eca" />

注意到32位其实会有问题，当我们需要调用多个函数的时候，会发现除了第一次调用函数之外后面的会不正确，有以下解决方案：

1.寻找pop|ret gadget来清理参数。

2.通过多次的栈迁移来调整栈指针的位置。

3.覆盖next func位为触发栈溢出的函数，重新执行一遍，就可以再次像第一次调用那样随意传参。

ret2libc是最简单也是最基础的手法，主要以栈溢出作为支撑。
